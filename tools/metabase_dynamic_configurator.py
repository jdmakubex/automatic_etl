#!/usr/bin/env python3
"""
Metabase Dynamic Configurator
============================

Configurador din√°mico para Metabase que lee DB_CONNECTIONS del .env y:
- Conecta autom√°ticamente a ClickHouse
- Descubre esquemas y tablas din√°micamente 
- Crea preguntas y dashboards autom√°ticamente
- Se adapta a cualquier configuraci√≥n sin hardcodear nombres

Similar al configurador de Superset pero para Metabase API.
"""
import os
import json
import time
import requests
import logging
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv

# Importar helper de descubrimiento de esquemas
import sys
sys.path.append('/app/tools')

class MetabaseSchemaDiscovery:
    """Helper simplificado para descubrimiento cuando no se puede importar el m√≥dulo completo"""
    def __init__(self):
        self.clickhouse_host = os.getenv("CLICKHOUSE_HOST", "clickhouse")
        self.clickhouse_database = os.getenv("CLICKHOUSE_DATABASE", "fgeo_analytics")
    
    def discover_available_schemas(self) -> List[str]:
        """Descubrimiento b√°sico de esquemas"""
        db_connections_str = os.getenv("DB_CONNECTIONS", "[]")
        try:
            connections = json.loads(db_connections_str)
            if isinstance(connections, dict):
                connections = [connections]
            
            schemas = []
            for conn in connections:
                db_name = conn.get("db", "")
                if db_name:
                    conn_name = conn.get("name", db_name)
                    ch_schema = f"fgeo_{conn_name}"
                    schemas.append(ch_schema)
            
            if not schemas:
                schemas.append(self.clickhouse_database)
            
            return sorted(set(schemas))
        except:
            return [self.clickhouse_database]
    
    def get_schema_table_info(self, schema: str) -> Dict[str, Any]:
        """Info b√°sica del esquema"""
        return {"total_tables": 0, "total_rows": 0, "tables": []}
    
    def create_dynamic_card_config(self, schema: str, table: str, query_type: str) -> Dict[str, Any]:
        """Configuraci√≥n b√°sica de tarjeta"""
        queries = {
            "overview": f"SELECT * FROM {schema}.{table} LIMIT 10",
            "count": f"SELECT COUNT(*) as total FROM {schema}.{table}",
            "recent": f"SELECT * FROM {schema}.{table} ORDER BY ingested_at DESC LIMIT 5"
        }
        
        icons = {"overview": "üìä", "count": "üî¢", "recent": "‚è∞"}
        displays = {"overview": "table", "count": "scalar", "recent": "table"}
        
        clean_schema = schema.replace("fgeo_", "").title()
        clean_table = table.replace("_", " ").title()
        
        return {
            "name": f"{icons.get(query_type, 'üìä')} {clean_schema} - {clean_table}",
            "description": f"Vista {query_type} para {table} en {schema}",
            "query": queries.get(query_type, queries["overview"]),
            "display": displays.get(query_type, "table"),
            "visualization_settings": {}
        }

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

load_dotenv('/app/.env')

class MetabaseDynamicConfigurator:
    """Configurador din√°mico completo para Metabase"""
    
    def __init__(self):
        """Inicializa el configurador con variables de entorno"""
        self.metabase_url = os.getenv("METABASE_URL", "http://metabase:3000")
        self.admin_user = os.getenv("METABASE_ADMIN", "admin")
        self.admin_password = os.getenv("METABASE_PASSWORD", "Metabase123!")
        
        # ClickHouse connection details
        self.clickhouse_host = os.getenv("CLICKHOUSE_HOST", "clickhouse")
        self.clickhouse_port = int(os.getenv("CLICKHOUSE_HTTP_PORT", "8123"))
        self.clickhouse_user = os.getenv("CH_USER", "etl")
        self.clickhouse_password = os.getenv("CH_PASSWORD", "Et1Ingest!")
        self.clickhouse_database = os.getenv("CLICKHOUSE_DATABASE", "fgeo_analytics")
        
        # Parse DB_CONNECTIONS for dynamic schema discovery
        self.db_connections = self._parse_db_connections()
        
        # Inicializar helper de descubrimiento
        self.schema_discovery = MetabaseSchemaDiscovery()
        
        # API endpoints
        self.session_endpoint = f"{self.metabase_url}/api/session"
        self.database_endpoint = f"{self.metabase_url}/api/database"
        self.card_endpoint = f"{self.metabase_url}/api/card"
        self.dashboard_endpoint = f"{self.metabase_url}/api/dashboard"
        
        self.session_id = None
        self.clickhouse_db_id = None
        
        logger.info(f"üîß Metabase Dynamic Configurator inicializado")
        logger.info(f"üìç URL: {self.metabase_url}")
        logger.info(f"üë§ Usuario: {self.admin_user}")
        logger.info(f"üóÑÔ∏è  ClickHouse: {self.clickhouse_host}:{self.clickhouse_port}/{self.clickhouse_database}")
        logger.info(f"üìä Esquemas detectados desde DB_CONNECTIONS: {len(self.db_connections)}")
    
    def _parse_db_connections(self) -> List[Dict[str, Any]]:
        """Parse DB_CONNECTIONS para descubrir esquemas din√°micamente"""
        db_connections_str = os.getenv("DB_CONNECTIONS", "[]")
        
        try:
            connections = json.loads(db_connections_str)
            if isinstance(connections, dict):
                connections = [connections]
            
            # Filtrar schemas de sistema como en Superset
            system_schemas = {"information_schema", "mysql", "performance_schema", "sys"}
            excluded_patterns = ["_analytics", "ext", "default", "system"]
            
            valid_connections = []
            for conn in connections:
                db_name = conn.get("db", "")
                if db_name and db_name not in system_schemas:
                    # Excluir patrones t√©cnicos
                    if not any(pattern in db_name for pattern in excluded_patterns):
                        valid_connections.append(conn)
                        logger.info(f"   ‚úÖ Esquema: {db_name} ({conn.get('name', 'unnamed')})")
                    else:
                        logger.info(f"   ‚ö†Ô∏è  Esquema excluido: {db_name} (patr√≥n t√©cnico)")
                else:
                    logger.info(f"   ‚ùå Esquema inv√°lido: {db_name} (sistema)")
            
            return valid_connections
            
        except json.JSONDecodeError as e:
            logger.error(f"‚ùå Error parseando DB_CONNECTIONS: {e}")
            return []
    
    def get_dynamic_schemas(self) -> List[str]:
        """Obtiene lista de esquemas ClickHouse din√°micamente usando el helper"""
        return self.schema_discovery.discover_available_schemas()
    
    def wait_for_metabase(self, max_attempts: int = 30) -> bool:
        """Espera a que Metabase est√© disponible"""
        logger.info("‚è≥ Esperando que Metabase est√© disponible...")
        
        for attempt in range(max_attempts):
            try:
                response = requests.get(f"{self.metabase_url}/api/health", timeout=5)
                if response.status_code == 200:
                    logger.info("‚úÖ Metabase est√° disponible")
                    return True
            except requests.exceptions.RequestException:
                pass
            
            if attempt < max_attempts - 1:
                time.sleep(5)
                logger.info(f"   Intento {attempt + 1}/{max_attempts}...")
        
        logger.error("‚ùå Metabase no respondi√≥ a tiempo")
        return False
    
    def authenticate(self) -> bool:
        """Autentica con el usuario admin de Metabase"""
        logger.info("üîê Autenticando en Metabase...")
        
        try:
            payload = {
                "username": self.admin_user,
                "password": self.admin_password
            }
            
            response = requests.post(self.session_endpoint, json=payload)
            if response.status_code == 200:
                self.session_id = response.json()["id"]
                logger.info("‚úÖ Autenticaci√≥n exitosa")
                return True
            else:
                logger.error(f"‚ùå Error de autenticaci√≥n: {response.status_code} - {response.text}")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Error de conexi√≥n durante autenticaci√≥n: {e}")
            return False
    
    def create_or_get_clickhouse_connection(self) -> Optional[int]:
        """Crea o obtiene la conexi√≥n a ClickHouse din√°micamente"""
        logger.info("üîó Configurando conexi√≥n a ClickHouse...")
        
        headers = {"X-Metabase-Session": self.session_id}
        
        try:
            # Verificar si ya existe una conexi√≥n ClickHouse
            response = requests.get(self.database_endpoint, headers=headers)
            if response.status_code == 200:
                databases = response.json()["data"]
                for db in databases:
                    if db.get("engine") == "clickhouse":
                        self.clickhouse_db_id = db["id"]
                        logger.info(f"‚úÖ Conexi√≥n ClickHouse existente encontrada (ID: {self.clickhouse_db_id})")
                        return self.clickhouse_db_id
            
            # Crear nueva conexi√≥n
            logger.info("üìù Creando nueva conexi√≥n a ClickHouse...")
            payload = {
                "name": f"ClickHouse ETL ({self.clickhouse_database})",
                "engine": "clickhouse",
                "details": {
                    "host": self.clickhouse_host,
                    "port": self.clickhouse_port,
                    "user": self.clickhouse_user,
                    "password": self.clickhouse_password,
                    "dbname": self.clickhouse_database,
                    "ssl": False,
                    "additional_options": "",
                    "let_user_control_scheduling": True,
                    "cache_field_values_schedule": "0 * * * *",
                    "metadata_sync_schedule": "0 * * * *"
                },
                "is_full_sync": True,
                "is_on_demand": False,
                "cache_ttl": None
            }
            
            response = requests.post(self.database_endpoint, json=payload, headers=headers)
            if response.status_code == 200:
                self.clickhouse_db_id = response.json()["id"]
                logger.info(f"‚úÖ Conexi√≥n ClickHouse creada (ID: {self.clickhouse_db_id})")
                
                # Forzar sincronizaci√≥n de esquemas
                self.sync_database_schema()
                return self.clickhouse_db_id
            else:
                logger.error(f"‚ùå Error creando conexi√≥n: {response.status_code} - {response.text}")
                return None
                
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Error configurando conexi√≥n ClickHouse: {e}")
            return None
    
    def sync_database_schema(self) -> bool:
        """Sincroniza esquemas de ClickHouse"""
        if not self.clickhouse_db_id:
            return False
        
        logger.info("üîÑ Sincronizando esquemas de ClickHouse...")
        headers = {"X-Metabase-Session": self.session_id}
        
        try:
            # Sincronizaci√≥n de esquemas
            sync_url = f"{self.database_endpoint}/{self.clickhouse_db_id}/sync_schema"
            response = requests.post(sync_url, headers=headers)
            
            if response.status_code == 200:
                logger.info("‚úÖ Sincronizaci√≥n de esquemas exitosa")
                
                # Rescaneo de valores
                rescan_url = f"{self.database_endpoint}/{self.clickhouse_db_id}/rescan_values"
                rescan_response = requests.post(rescan_url, headers=headers)
                
                if rescan_response.status_code == 200:
                    logger.info("‚úÖ Re-escaneo de valores exitoso")
                else:
                    logger.warning(f"‚ö†Ô∏è  Re-escaneo fall√≥: {rescan_response.status_code}")
                
                # Esperar que termine la sincronizaci√≥n
                time.sleep(10)
                return True
            else:
                logger.error(f"‚ùå Error en sincronizaci√≥n: {response.status_code} - {response.text}")
                return False
                
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Error sincronizando esquemas: {e}")
            return False
    
    def discover_tables(self) -> Dict[str, List[str]]:
        """Descubre tablas disponibles en los esquemas din√°micamente"""
        if not self.clickhouse_db_id:
            return {}
        
        logger.info("üîç Descubriendo tablas disponibles...")
        headers = {"X-Metabase-Session": self.session_id}
        
        try:
            # Obtener metadata completa de la base de datos
            metadata_url = f"{self.database_endpoint}/{self.clickhouse_db_id}/metadata"
            response = requests.get(metadata_url, headers=headers)
            
            if response.status_code == 200:
                metadata = response.json()
                tables_by_schema = {}
                
                for table in metadata.get("tables", []):
                    schema = table.get("schema", "default")
                    table_name = table.get("name", "")
                    
                    if schema not in tables_by_schema:
                        tables_by_schema[schema] = []
                    
                    if table_name:
                        tables_by_schema[schema].append(table_name)
                
                # Log resultados
                for schema, tables in tables_by_schema.items():
                    logger.info(f"   üìä Esquema '{schema}': {len(tables)} tablas")
                    for table in tables[:3]:  # Mostrar primeras 3
                        logger.info(f"      - {table}")
                    if len(tables) > 3:
                        logger.info(f"      ... y {len(tables) - 3} m√°s")
                
                return tables_by_schema
            else:
                logger.error(f"‚ùå Error obteniendo metadata: {response.status_code}")
                return {}
                
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Error descubriendo tablas: {e}")
            return {}
    
    def create_dynamic_questions(self, tables_by_schema: Dict[str, List[str]]) -> List[int]:
        """Crea preguntas din√°micas avanzadas para cada esquema/tabla"""
        logger.info("‚ùì Creando preguntas din√°micas avanzadas...")
        headers = {"X-Metabase-Session": self.session_id}
        created_cards = []
        
        for schema, tables in tables_by_schema.items():
            logger.info(f"   üìù Esquema: {schema}")
            
            # Obtener informaci√≥n detallada del esquema
            schema_info = self.schema_discovery.get_schema_table_info(schema)
            
            # Crear m√∫ltiples tipos de preguntas para cada tabla
            for table in tables[:3]:  # Limitar a 3 tablas por esquema para no saturar
                try:
                    query_types = ["overview", "count", "recent"]
                    
                    for query_type in query_types:
                        # Usar el helper para generar configuraci√≥n din√°mica
                        card_config = self.schema_discovery.create_dynamic_card_config(
                            schema, table, query_type
                        )
                        
                        payload = {
                            "name": card_config["name"],
                            "description": card_config["description"],
                            "dataset_query": {
                                "type": "native",
                                "native": {
                                    "query": card_config["query"]
                                },
                                "database": self.clickhouse_db_id
                            },
                            "display": card_config["display"],
                            "visualization_settings": card_config["visualization_settings"]
                        }
                        
                        response = requests.post(self.card_endpoint, json=payload, headers=headers)
                        if response.status_code == 200:
                            card_id = response.json()["id"]
                            created_cards.append(card_id)
                            logger.info(f"      ‚úÖ {card_config['name']} (ID: {card_id})")
                        else:
                            logger.warning(f"      ‚ö†Ô∏è  Error creando {query_type} para {table}: {response.status_code}")
                
                except Exception as e:
                    logger.warning(f"      ‚ùå Error procesando tabla {table}: {e}")
            
            # Crear pregunta de resumen del esquema con datos reales
            if schema_info.get("total_tables", 0) > 0:
                try:
                    clean_schema = schema.replace("fgeo_", "").title()
                    summary_name = f"üìà {clean_schema} - Dashboard Resumen"
                    summary_query = f"""
                    SELECT 
                        '{clean_schema}' as Esquema,
                        {schema_info['total_tables']} as Tablas,
                        {schema_info['total_rows']} as Filas_Totales,
                        'An√°lisis autom√°tico completado' as Estado
                    """
                    
                    summary_payload = {
                        "name": summary_name,
                        "description": f"Resumen ejecutivo del esquema {schema} con m√©tricas reales",
                        "dataset_query": {
                            "type": "native",
                            "native": {
                                "query": summary_query
                            },
                            "database": self.clickhouse_db_id
                        },
                        "display": "table",
                        "visualization_settings": {
                            "table.pivot_column": "Esquema",
                            "table.cell_column": "Filas_Totales"
                        }
                    }
                    
                    response = requests.post(self.card_endpoint, json=summary_payload, headers=headers)
                    if response.status_code == 200:
                        card_id = response.json()["id"]
                        created_cards.append(card_id)
                        logger.info(f"   ‚úÖ Resumen ejecutivo creado: {summary_name} (ID: {card_id})")
                
                except Exception as e:
                    logger.warning(f"   ‚ùå Error creando resumen ejecutivo para {schema}: {e}")
        
        logger.info(f"‚úÖ {len(created_cards)} preguntas din√°micas avanzadas creadas")
        return created_cards
    
    def create_dynamic_dashboard(self, card_ids: List[int]) -> Optional[int]:
        """Crea dashboard din√°mico con las preguntas generadas"""
        if not card_ids:
            return None
        
        logger.info("üìä Creando dashboard din√°mico...")
        headers = {"X-Metabase-Session": self.session_id}
        
        try:
            # Crear dashboard
            dashboard_payload = {
                "name": "üöÄ ETL Analytics - Dashboard Autom√°tico",
                "description": f"Dashboard generado autom√°ticamente con {len(card_ids)} visualizaciones basadas en DB_CONNECTIONS"
            }
            
            response = requests.post(self.dashboard_endpoint, json=dashboard_payload, headers=headers)
            if response.status_code == 200:
                dashboard_id = response.json()["id"]
                logger.info(f"‚úÖ Dashboard creado (ID: {dashboard_id})")
                
                # Agregar tarjetas al dashboard
                dashboard_cards = []
                row = 0
                col = 0
                
                for i, card_id in enumerate(card_ids[:12]):  # M√°ximo 12 tarjetas
                    dashboard_cards.append({
                        "id": card_id,
                        "card_id": card_id,
                        "row": row,
                        "col": col,
                        "sizeX": 6,
                        "sizeY": 4,
                        "series": [],
                        "visualization_settings": {},
                        "parameter_mappings": []
                    })
                    
                    col += 6
                    if col >= 12:  # Nueva fila cada 2 tarjetas
                        col = 0
                        row += 4
                
                # Actualizar dashboard con tarjetas
                update_payload = {
                    "ordered_cards": dashboard_cards
                }
                
                update_response = requests.put(
                    f"{self.dashboard_endpoint}/{dashboard_id}/cards", 
                    json=update_payload, 
                    headers=headers
                )
                
                if update_response.status_code == 200:
                    logger.info(f"‚úÖ {len(dashboard_cards)} tarjetas agregadas al dashboard")
                    logger.info(f"üîó Acceso: {self.metabase_url}/dashboard/{dashboard_id}")
                    return dashboard_id
                else:
                    logger.warning(f"‚ö†Ô∏è  Error agregando tarjetas: {update_response.status_code}")
                    return dashboard_id
            else:
                logger.error(f"‚ùå Error creando dashboard: {response.status_code} - {response.text}")
                return None
                
        except requests.exceptions.RequestException as e:
            logger.error(f"‚ùå Error creando dashboard: {e}")
            return None
    
    def run_configuration(self) -> bool:
        """Ejecuta la configuraci√≥n completa de Metabase"""
        logger.info("üöÄ INICIANDO CONFIGURACI√ìN DIN√ÅMICA DE METABASE")
        logger.info("=" * 60)
        
        try:
            # 1. Verificar disponibilidad
            if not self.wait_for_metabase():
                return False
            
            # 2. Autenticar
            if not self.authenticate():
                return False
            
            # 3. Configurar conexi√≥n ClickHouse
            if not self.create_or_get_clickhouse_connection():
                return False
            
            # 4. Descubrir tablas
            tables_by_schema = self.discover_tables()
            if not tables_by_schema:
                logger.warning("‚ö†Ô∏è  No se encontraron tablas, continuando con configuraci√≥n b√°sica...")
                return True
            
            # 5. Crear preguntas din√°micas
            card_ids = self.create_dynamic_questions(tables_by_schema)
            
            # 6. Crear dashboard din√°mico
            dashboard_id = self.create_dynamic_dashboard(card_ids)
            
            # Resumen final
            logger.info("\n" + "=" * 60)
            logger.info("‚úÖ ¬°CONFIGURACI√ìN DIN√ÅMICA COMPLETADA!")
            logger.info(f"üîó URL de acceso: {self.metabase_url}")
            logger.info(f"üë§ Usuario: {self.admin_user}")
            logger.info(f"üîë Contrase√±a: {self.admin_password}")
            logger.info(f"üìä Esquemas configurados: {len(tables_by_schema)}")
            logger.info(f"‚ùì Preguntas creadas: {len(card_ids)}")
            if dashboard_id:
                logger.info(f"üìà Dashboard: {self.metabase_url}/dashboard/{dashboard_id}")
            logger.info("=" * 60)
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error durante configuraci√≥n: {e}")
            return False


def main():
    """Funci√≥n principal"""
    configurator = MetabaseDynamicConfigurator()
    success = configurator.run_configuration()
    
    if success:
        logger.info("üéâ Configuraci√≥n din√°mica de Metabase completada exitosamente")
        return 0
    else:
        logger.error("üí• Fall√≥ la configuraci√≥n din√°mica de Metabase")
        return 1


if __name__ == "__main__":
    import sys
    sys.exit(main())