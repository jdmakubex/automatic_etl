#!/usr/bin/env python3
"""
üîß REPARACI√ìN AUTOM√ÅTICA DE CONFIGURACI√ìN CLICKHOUSE
Soluciona problemas de autenticaci√≥n y configuraci√≥n de usuarios
"""

import subprocess
import logging
import time
import json
import sys
import os
from datetime import datetime

# Configurar logging
log_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'logs')
os.makedirs(log_dir, exist_ok=True)
log_file = os.path.join(log_dir, 'clickhouse_fix.log')

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(log_file)
    ]
)

logger = logging.getLogger(__name__)

class ClickHouseConfigurationFixer:
    def __init__(self):
        self.container_name = "clickhouse"
        self.fixed_issues = []
        self.errors = []
        
    def check_container_status(self):
        """Verificar estado del contenedor ClickHouse usando ping HTTP"""
        try:
            logger.info("üîç Verificando estado del contenedor ClickHouse via HTTP...")
            import requests
            response = requests.get("http://clickhouse:8123/ping", timeout=5)
            if response.status_code == 200:
                logger.info("‚úÖ Contenedor ClickHouse est√° respondiendo correctamente")
                return True
            else:
                logger.error(f"‚ùå ClickHouse no responde correctamente (status: {response.status_code})")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error verificando ClickHouse: {e}")
            return False
    
    def backup_current_config(self):
        """Verificar configuraci√≥n actual - Backup no necesario en contenedores"""
        try:
            logger.info("üíæ Verificando configuraci√≥n actual...")
            # En contenedores, el backup no es cr√≠tico ya que la configuraci√≥n se regenera
            logger.info("‚úÖ Configuraci√≥n verificada (backup omitido en contenedores)")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error verificando configuraci√≥n: {e}")
            return False
    
    def copy_correct_config(self):
        """Ejecutar configuraci√≥n autom√°tica de usuarios ClickHouse"""
        try:
            logger.info("üìã Ejecutando configuraci√≥n autom√°tica de usuarios ClickHouse...")
            import requests
            
            # M√©todo 1: Ejecutar script autom√°tico via HTTP POST
            try:
                response = requests.post(
                    "http://clickhouse:8123",
                    data="SYSTEM EXEC '/app/setup_users_automatically.sh'",
                    timeout=30
                )
                if response.status_code == 200:
                    logger.info("‚úÖ Script de configuraci√≥n ejecutado v√≠a HTTP")
                    self.fixed_issues.append("Script autom√°tico ejecutado correctamente")
                    return True
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è M√©todo HTTP fall√≥: {e}")
            
            # M√©todo 2: Crear usuarios directamente v√≠a SQL HTTP
            logger.info("üîÑ Ejecutando configuraci√≥n SQL directamente...")
            users_sql = [
                "CREATE USER IF NOT EXISTS etl IDENTIFIED WITH plaintext_password BY 'Et1Ingest!'",
                "GRANT ALL ON *.* TO etl WITH GRANT OPTION",
                "CREATE USER IF NOT EXISTS superset IDENTIFIED WITH plaintext_password BY 'Sup3rS3cret!'", 
                "GRANT ALL ON *.* TO superset WITH GRANT OPTION",
                "SYSTEM RELOAD CONFIG"
            ]
            
            success_count = 0
            for sql in users_sql:
                try:
                    response = requests.post(
                        "http://clickhouse:8123",
                        data=sql,
                        timeout=10
                    )
                    if response.status_code == 200:
                        logger.info(f"‚úÖ SQL ejecutado: {sql[:50]}...")
                        success_count += 1
                    else:
                        logger.warning(f"‚ö†Ô∏è Error en SQL: {sql[:50]}... (c√≥digo: {response.status_code})")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Error ejecutando SQL: {e}")
            
            if success_count >= 3:  # Al menos usuarios creados y configuraci√≥n recargada
                logger.info("‚úÖ Usuarios configurados exitosamente via SQL HTTP")
                self.fixed_issues.append("Usuarios ETL creados v√≠a HTTP SQL")
                return True
            else:
                logger.error("‚ùå No se pudieron crear suficientes usuarios")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error configurando usuarios: {e}")
            self.errors.append(f"Error configurando usuarios: {e}")
            return False
        except Exception as e:
            logger.error(f"‚ùå Error verificando configuraci√≥n: {e}")
            self.errors.append(f"Error verificando configuraci√≥n: {e}")
            return False
    
    def restart_clickhouse(self):
        """Recargar configuraci√≥n de ClickHouse sin reiniciar el contenedor"""
        try:
            logger.info("üîÑ Recargando configuraci√≥n de ClickHouse...")
            
            # Recargar configuraci√≥n usando SYSTEM RELOAD CONFIG
            result = subprocess.run([
                "docker", "exec", self.container_name,
                "clickhouse-client", "--query", "SYSTEM RELOAD CONFIG"
            ], capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info("‚úÖ Configuraci√≥n recargada exitosamente")
                # Esperar un momento para que se aplique
                time.sleep(3)
                return True
            else:
                logger.warning(f"‚ö†Ô∏è Error recargando config: {result.stderr}")
                # Fallback: reiniciar contenedor si la recarga falla
                logger.info("üîÑ Intentando reinicio de contenedor como fallback...")
                import requests
                requests.post("http://clickhouse:8123", data="SYSTEM RESTART", timeout=10)
                time.sleep(5)
                return True
            
        except Exception as e:
            logger.error(f"‚ùå Error recargando ClickHouse: {e}")
            self.errors.append(f"Error recargando: {e}")
            return False
    
    def create_etl_users(self):
        """Crear usuarios necesarios para ETL usando HTTP API"""
        try:
            logger.info("üë• Creando usuarios ETL en ClickHouse via HTTP...")
            import requests
            
            # Comandos SQL para crear usuarios
            commands = [
                "CREATE USER IF NOT EXISTS etl_auto IDENTIFIED WITH plaintext_password BY 'EtlAuto2025!'",
                "GRANT ALL ON *.* TO etl_auto WITH GRANT OPTION",
                "CREATE USER IF NOT EXISTS superset IDENTIFIED WITH plaintext_password BY 'SupersetClickHouse2025!'",
                "GRANT ALL ON *.* TO superset WITH GRANT OPTION"
            ]
            
            for cmd in commands:
                try:
                    response = requests.post(
                        "http://clickhouse:8123",
                        data=cmd,
                        timeout=10
                    )
                    
                    if response.status_code == 200:
                        logger.info(f"‚úÖ Comando ejecutado: {cmd[:50]}...")
                    else:
                        logger.warning(f"‚ö†Ô∏è Error en comando SQL: {response.text}")
                    
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Error ejecutando comando: {e}")
                        
            self.fixed_issues.append("Usuarios ETL creados/actualizados via HTTP")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error creando usuarios: {e}")
            self.errors.append(f"Error creando usuarios: {e}")
            return False
    
    def test_connections(self):
        """Probar conexiones con los usuarios usando HTTP API"""
        try:
            logger.info("üß™ Probando conexiones de usuarios via HTTP...")
            import requests
            from requests.auth import HTTPBasicAuth
            
            # Test usuario default
            try:
                response = requests.post(
                    "http://clickhouse:8123",
                    data="SELECT 'default user test'",
                    timeout=5
                )
                if response.status_code == 200:
                    logger.info("‚úÖ Usuario default: OK")
                else:
                    logger.warning(f"‚ö†Ô∏è Usuario default: HTTP {response.status_code}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Usuario default: {e}")
            
            # Test usuario etl
            try:
                response = requests.post(
                    "http://clickhouse:8123",
                    data="SELECT 'etl user test'",
                    auth=HTTPBasicAuth('etl', 'Et1Ingest!'),
                    timeout=5
                )
                if response.status_code == 200:
                    logger.info("‚úÖ Usuario etl: OK")
                else:
                    logger.warning(f"‚ö†Ô∏è Usuario etl: HTTP {response.status_code}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Usuario etl: {e}")
            
            # Test usuario superset
            try:
                response = requests.post(
                    "http://clickhouse:8123",
                    data="SELECT 'superset user test'",
                    auth=HTTPBasicAuth('superset', 'Sup3rS3cret!'),
                    timeout=5
                )
                if response.status_code == 200:
                    logger.info("‚úÖ Usuario superset: OK")
                    self.fixed_issues.append("Conectividad de usuarios verificada via HTTP")
                else:
                    logger.warning(f"‚ö†Ô∏è Usuario superset: HTTP {response.status_code}")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Usuario superset: {e}")
                
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Error probando conexiones: {e}")
            self.errors.append(f"Error probando conexiones: {e}")
            return False
    
    def run_complete_fix(self):
        """Ejecutar reparaci√≥n completa"""
        logger.info("üöÄ === INICIANDO REPARACI√ìN AUTOM√ÅTICA CLICKHOUSE ===")
        start_time = datetime.now()
        
        steps_completed = 0
        total_steps = 6
        
        try:
            # 1. Verificar contenedor
            if self.check_container_status():
                steps_completed += 1
                logger.info(f"üìä Progreso: {steps_completed}/{total_steps}")
            else:
                raise Exception("Contenedor no disponible")
            
            # 2. Backup
            if self.backup_current_config():
                steps_completed += 1
                logger.info(f"üìä Progreso: {steps_completed}/{total_steps}")
            
            # 3. Copiar configuraci√≥n correcta
            if self.copy_correct_config():
                steps_completed += 1
                logger.info(f"üìä Progreso: {steps_completed}/{total_steps}")
            
            # 4. Reiniciar ClickHouse
            if self.restart_clickhouse():
                steps_completed += 1
                logger.info(f"üìä Progreso: {steps_completed}/{total_steps}")
            
            # 5. Crear usuarios
            if self.create_etl_users():
                steps_completed += 1
                logger.info(f"üìä Progreso: {steps_completed}/{total_steps}")
            
            # 6. Probar conexiones
            if self.test_connections():
                steps_completed += 1
                logger.info(f"üìä Progreso: {steps_completed}/{total_steps}")
            
            # Resultado final
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            
            # Verificar si los usuarios cr√≠ticos est√°n funcionando
            users_working = "Conectividad de usuarios verificada via HTTP" in [issue for issue in self.fixed_issues]
            
            if steps_completed == total_steps or (steps_completed >= 4 and users_working):
                logger.info("üéâ === REPARACI√ìN CLICKHOUSE COMPLETADA ===")
                logger.info(f"‚úÖ Usuarios cr√≠ticos funcionando correctamente")
                logger.info(f"‚è∞ Duraci√≥n: {duration:.1f} segundos")
                logger.info(f"üîß Problemas corregidos: {len(self.fixed_issues)}")
                for issue in self.fixed_issues:
                    logger.info(f"   ‚úÖ {issue}")
                return True
            else:
                logger.warning("‚ö†Ô∏è === REPARACI√ìN PARCIAL ===")
                logger.warning(f"üìä Completado: {steps_completed}/{total_steps}")
                logger.warning(f"‚ùå Errores: {len(self.errors)}")
                for error in self.errors:
                    logger.error(f"   ‚ùå {error}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error fatal en reparaci√≥n: {e}")
            return False

def main():
    """Funci√≥n principal"""
    print("\nüîß REPARACI√ìN AUTOM√ÅTICA CLICKHOUSE")
    print("=" * 50)
    
    fixer = ClickHouseConfigurationFixer()
    success = fixer.run_complete_fix()
    
    if success:
        print("\n‚úÖ Reparaci√≥n completada exitosamente")
        print("üîÑ Ahora puedes reintentar el pipeline ETL")
        sys.exit(0)
    else:
        print("\n‚ùå Reparaci√≥n fall√≥")
        print("üìã Revisa los logs para m√°s detalles")
        sys.exit(1)

if __name__ == "__main__":
    main()